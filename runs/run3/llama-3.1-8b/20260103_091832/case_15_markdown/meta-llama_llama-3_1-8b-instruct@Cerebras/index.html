<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown Editor</title>
    <style>
        body {
            font-family: monospace;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .left-pane {
            width: 50%;
            padding: 20px;
            overflow-y: auto;
        }
        .right-pane {
            width: 50%;
            padding: 20px;
        }
        .toggle {
            position: absolute;
            top: 10px;
            right: 10px;
        }
        .toggle-input {
            display: none;
        }
        .toggle-input:checked + label {
            background-color: #333;
        }
        .toggle-input:checked + label span {
            color: #fff;
        }
        .export-button {
            position: absolute;
            bottom: 10px;
            right: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-pane">
            <textarea id="markdown-input" rows="30" cols="50"></textarea>
            <input type="checkbox" id="dark-mode" class="toggle-input">
            <label for="dark-mode" class="toggle">
                <span></span>
            </label>
            <button class="export-button">Export as HTML</button>
        </div>
        <div class="right-pane">
            <div id="preview"></div>
        </div>
    </div>

    <script>
        const markdownInput = document.getElementById('markdown-input');
        const preview = document.getElementById('preview');
        const darkModeToggle = document.getElementById('dark-mode');
        const exportButton = document.getElementById('export-button');
        let isDarkMode = false;

        markdownInput.addEventListener('input', () => {
            const markdown = markdownInput.value;
            const html = markdownToHtml(markdown);
            preview.innerHTML = html;
            localStorage.setItem('markdown', markdown);
            localStorage.setItem('html', html);
        });

        darkModeToggle.addEventListener('change', () => {
            isDarkMode = darkModeToggle.checked;
            document.body.classList.toggle('dark-mode', isDarkMode);
        });

        exportButton.addEventListener('click', () => {
            const html = markdownInput.value;
            const blob = new Blob([html], {type: 'text/html'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'markdown.html';
            a.click();
            URL.revokeObjectURL(url);
        });

        function markdownToHtml(markdown) {
            const lines = markdown.split('\n');
            const html = [];
            let inCodeBlock = false;
            let codeBlockLines = [];

            for (const line of lines) {
                if (line.trim().startsWith('```')) {
                    inCodeBlock = !inCodeBlock;
                    if (inCodeBlock) {
                        codeBlockLines = [];
                    } else {
                        html.push('<pre><code>' + codeBlockLines.join('\n') + '</code></pre>');
                    }
                } else if (inCodeBlock) {
                    codeBlockLines.push(line);
                } else {
                    const match = line.match(/^#* (.*)$/);
                    if (match) {
                        html.push('<h' + match[1].length + '>' + match[1] + '</h' + match[1].length + '>');
                    } else {
                        const match = line.match(/^>\s*(.*)$/);
                        if (match) {
                            html.push('<blockquote>' + match[1] + '</blockquote>');
                        } else {
                            const match = line.match(/^\* (.*)$/);
                            if (match) {
                                html.push('<em>' + match[1] + '</em>');
                            } else if (line.startsWith('[')) {
                                const match = line.match(/\[(.*)\]\((.*)\)/);
                                if (match) {
                                    html.push('<a href="' + match[2] + '">' + match[1] + '</a>');
                                }
                            } else {
                                html.push('<p>' + line + '</p>');
                            }
                        }
                    }
                }
            }

            if (codeBlockLines.length) {
                html.push('<pre><code>' + codeBlockLines.join('\n') + '</code></pre>');
            }

            return html.join('\n');
        }

        markdownInput.value = localStorage.getItem('markdown') || '';
        preview.innerHTML = localStorage.getItem('html') || '';
        darkModeToggle.checked = localStorage.getItem('dark-mode') === 'true';
        document.body.classList.toggle('dark-mode', darkModeToggle.checked);
    </script>
</body>
</html>